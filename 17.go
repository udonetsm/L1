package main

import (
	"log"
)

/* Находит первое вхождение искомого */
func BinarySearch(sorted, result []int, target int) []int {
	// изначально границы поиска между нулевым и последний элементом
	lendata := len(sorted)
	first := 0
	//чтобы сохранять сюда середину текущей области поиска и иметь к ней доступ вне цикла
	var mid int
	//Идем от начальной границы до конечной
	for first < lendata {
		//При первом вхождении искомого выходим из цикла
		if target == sorted[mid] {
			break
		}
		//если искомое больше чем значение в середине области поиска,
		//началом области поиска становится то значение, которое было серединой области +1
		//так как значение по середине тоже не искомое
		if target > sorted[mid] {
			log.Println(">", mid)
			first = mid + 1
		}
		//если искомое меньше, чем значение посередине области поиска,
		//то конечной границей области поиска становится середина-1
		//так как значение посередине не подошло тоже
		if target < sorted[mid] {
			log.Println("<", mid)
			lendata = mid - 1
		}
		//находим заново середину так как в условиях передвинули границы
		mid = (first + lendata) / 2

	}
	//добавляем в массив вхождений первый индекс содержащий искомое
	result = append(result, mid)
	//вызов нахождения повторных вхождений искомого в массиве по первому индексу который содержит искомое
	result = FindRepeated(target, mid, sorted, result)
	return result
}

//Здесь ничего интересного. QuickSort тот, что я сделал в одном из заданий уровня, чтобы не писать заново
//использую его
//Сортировка нужна так как бинарный поиск работает только на отсортированном массиве(слайсе)
func make_for_Binary(target int) {
	slc, result := make([]int, 0), make([]int, 0)
	slc = append(slc, 32, 1, 1, 1, 2, 5, 12, 87, 87, 87, 87, 87, 87, 87, 45, 344, 344, 12, 3, 89, 90, 43)
	slc = QuickSort(slc)
	//здесь вывод чтобы можно было убедится что поиск выводит индексы корректно и ничего не сдвигается
	log.Println(slc)
	result = BinarySearch(slc, result, target)
	//дополнительно сортирую все индексы с искомым для удобства восприятия
	result = QuickSort(result)
	log.Println(result)
}

//Принимает первый индекс с искомым и опираясь на него находит остальные вхождения искомого.
func FindRepeated(target, position int, sorted, result []int) []int {
	//Буфер
	p := position
	//проверка всех индексов следующих за первым вхождением
	for position <= len(sorted)-1 {
		//не допускаем выход за пределы массива(слайса), так как иначе будет паника, так как индекс не может быть > длины массива(слайса)
		if position+1 >= len(sorted) {
			break
		}
		// проверяем есть ли рядом с индексом, где было найдено искомое, еще одно искомое
		if sorted[position+1] == target {
			//и передвигаемся на следующий в порядке возрастания элемент
			position += 1
			//кладем найденный повторный индекс с искомым в слайс
			result = append(result, position)
			//либо завершаем поиск в порядке возрастания
		} else {
			break
		}

	}
	position = p
	//начало поиска в порядке убывания(здесь проверяются элементы слева от индекса с найденным искомым)
	for position >= 0 {
		//не выходим за 0 так как иначе паника
		if position-1 <= 0 {
			break
		}
		//Проверка предыдущего значения. Если повторное искомое, то
		if sorted[position-1] == target {
			//...передвигаем индекс на один влево
			position -= 1
			//...добавляем индекс повтора в результирующий слайс
			result = append(result, position)
		} else {
			break
		}
	}
	return result
}
